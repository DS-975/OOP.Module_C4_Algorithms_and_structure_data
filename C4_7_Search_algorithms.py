C4.7. Алгоритмы поиска

Перейти к основному содержимому
img

На текущий момент мы познакомились со всеми основными структурами данных и даже научились создавать собственные. Это победа!

Однако эти структуры существуют для какой-то цели. Одна из самых распространенных — поиск элемента в структуре. В этой части модуля мы рассмотрим базовые алгоритмы поиска в различных структурах.

Линейный поиск
Алгоритм линейного поиска определяется на таких структурах данных как массивы, списки и надстройки над ними — очередь и стек. Такой алгоритм является «решением в лоб» и сводится к перебору одного элемента за другим и операции сравнения на каждом. Как правило, линейный поиск применяется к неотсортированным структурам.

Пусть на вход программы поступает массив из произвольного количества целых чисел и еще одно целое число, которое будем проверять на вхождение в этот массив. Задача состоит в том, чтобы вернуть индекс первого вхождения элемента, если он входит в него, и False, если не входит.

def find(array, element):
    for i, a in enumerate(array):
        if a == element:
            return i
    return False

array = list(map(int, input().split()))
element = int(input())

print(find(array, element))
В худшем случае этот алгоритм работает за O(n), потому что, если элемент не входит в массив, придется провести n сравнений. Все они не увенчаются успехом.

Линейный алгоритм поиска может применяться для следующих целей:

Нахождение минимального/максимального элемента.
Поиск элемента с определенным значением.
Количество вхождений элемента в массив.
Количество элементов больше заданного.
В случае нахождения минимального (максимального) элемента линейный поиск имеет смысл применять только при небольшом количестве элементов, и если структура не отсортирована. Для больших структур, а тем более, если они уже сортированы, имеет смысл применять более эффективные алгоритмы.

Задание 4.7.1
Задание на самопроверку.

Напишите функцию count, которая возвращает количество вхождений элемента в массив

Ответ
def count(array, element):
    count = 0
    for a in array:
        if a == element:
            count += 1
    return count
Двоичный поиск
Алгоритм двоичного поиска является более совершенным, чем линейный поиск, однако он накладывает на структуру сильное ограничение — она должна быть отсортирована.

Допустим, что у нас стоит такая же задача — найти индекс определенного элемента в массиве. В связи с тем, что алгоритм может искать только в отсортированном массиве, используем генератор последовательных чисел range. Суть двоичного поиска сводится к тому, что на каждой итерации размер исследуемого массива уменьшается в 2 раза.

def binary_search(array, element, left, right): 
    if left > right:  # если левая граница превысила правую,
        return False  # значит элемент отсутствует
    
    middle = (right+left) // 2  # находим середину
    if array[middle] == element:  # если элемент в середине,
        return middle  # возвращаем этот индекс
    elif element < array[middle]:  # если элемент меньше элемента в середине
        # рекурсивно ищем в левой половине
        return binary_search(array, element, left, middle-1)
    else:  # иначе в правой
        return binary_search(array, element, middle+1, right)

element = int(input())
array = [i for i in range(1,100)] # 1,2,3,4,...

# запускаем алгоритм на левой и правой границе
print(binary_search(array, element, 0, 98))
Математически доказывается, что сложность такого алгоритма O(log(n)), а как вы должны помнить из начала этого модуля — логарифмическая сложность намного лучше, чем линейная. Ура! Мы получили очень эффективный алгоритм поиска. Только вот сортировать нужно… Но и с этим мы познакомимся чуть позже.

Несколько более сложный алгоритм, но в чем-то схожий с двоичным поиском — это использование двоичных деревьев поиска. Этот алгоритм концентрирует свойства бинарных деревьев для оптимизации задачи поиска. С ним можно ознакомиться в дополнительных материалах к теме .

