C4.6. Создание собственных структур

Перейти к основному содержимому
img

Ранее нами были рассмотрены следующие структуры данных:

Массив
Список
Стек
Очередь
Хэш-таблица (словарь)
Граф
Дерево
Для их конкретной реализации мы пользовались встроенными в Python типами данных — списками, реализующими динамический массив, и словарями, реализующими хэш-таблицы. Используя эти два базовых типа данных и принципы объектно-ориентированного программирования, мы создали конкретные реализации других типов данных. И, если честно, мы сделали костыли.

img

Да, конечно, в среднем мы достигали теоретической сложности определенных структур данных, оптимизируя встроенные типы данных. Однако интуиция должна подсказывать, что должен существовать способ создания собственных структур данных.

И если она вам это подсказывает, то вы не ошиблись! В прошлых модулях мы познакомились с такими объектами как итераторы.

Итератор — это пользовательский класс, в обязательном порядке реализующий два «магических» метода — iter и next.

Первый метод должен возвращать объект на итератор, а благодаря второму методу мы можем совершать обход по структуре.

Связанный список
Чтобы не углубляться дальше в теорию, давайте посмотрим, как можно создать собственную структуру данных, реализующую связанный список. В самом списке мы будем хранить указатель на первый элемент и на последний элемент. В таком случае давайте вспомним, какие операции можно делать со списком и их среднюю оценку сложности.

Задание 4.6.1
1 из 1 балла (оценивается)
 Помощь по управлению с клавиатуры
ЗАДАЧА
Соотнесите операции над списком и их сложности.

An isosceles triangle with three layers of similar height. It is shown upright, so the widest layer is located at the bottom, and the narrowest layer is located at the top.O(1), зона для перетаскиванияO(1)
Элементы, расположенные здесь: Вставка элемента в конец (push), Удаление элемента с конца (pop)O(n), зона для перетаскиванияO(n)
Элементы, расположенные здесь: Обход (iter), Получение размера списка (len), Поиск элемента по значению (find)
Отправить

Вернуться К Началу
Сбросить
Показать Ответ
ОБРАТНАЯ СВЯЗЬ
Correctly placed 5 items.

Your highest score is 1.0

Сейчас мы попробуем создать класс LinkedList, реализующий список. Элементы списка будут представлять собой экземпляры класса Node.

class Node:  # класс элемента
    def __init__(self, value = None, next_ = None):  # инициализируем
        self.value = value  # значением
        self.next = next_  # и ссылкой на следующий элемент

    def __str__(self):
        return "Node value = " + str(self.value)

class LinkedList:  # класс списка
    def __init__(self):  # инициализируем пустым
        self.first = None
        self.last = None
        
    def clear(self):  # очищаем список
        self.__init__()
    
    def __str__(self):  # функция печати 
        R = ''
        
        pointer = self.first  # берем первый указатель
        while pointer is not None:  # пока указатель не станет None
            R += str(pointer.value)  # добавляем значение в строку
            pointer = pointer.next  # идем дальше по указателю
            if pointer is not None:  # если он существует добавляем пробел
                R += ' '
        return R
Мы определили класс Node. Конструктор этого класса принимает значение элемента и ссылку на следующий элемент. По умолчанию они оба None. Также был определен метод __str__, который используется для строкового представления объекта.

Также был определен основной класс LinkedList. Конструктор метода инициализирует ссылки на первый и на последний элемент, а также определяется метод clear, который очищает список.

Сейчас шаг за шагом добавим методы, которые мы вспомнили в предыдущем задании. На первом шаге добавим метод pushleft, который вставляет новый элемент в начало списка.

def pushleft(self, value):
    if self.first is None:
        self.first = Node(value)
        self.last = self.first
    else:
        new_node = Node(value, self.first)
        self.first = new_node
Задание 4.6.2
Задание на самопроверку.

Напишите функцию pushright, которая добавляет элемент в правую часть списка.

Ответ
def pushright(self, value):
    if self.first is None:
        self.first = Node(value)
        self.last = self.first
    else:
        new_node = Node(value)
        self.last.next = new_node    
        self.last = new_node
С удалением элементов несколько интереснее. Удалить элемент из начала можно без особого труда: достаточно изменить указатель на первый элемент. Удалить элемент из конца более затруднительно, потому что, удалив последний элемент, мы потеряем ссылку на него. В таком случае время выполнения операции будет равно O(n).

Существуют способы улучшить и этот аспект. Одно из решений — создание двусвязного списка, в котором помимо указателя на следующий элемент будет храниться указатель и на предыдущий элемент. Или можно модифицировать односвязный список, сохраняя еще и указатель на предпоследний элемент. Оба способа требуют дополнительной памяти, но в данном случае мы пожертвуем производительностью ради памяти и скорости разработки (что тоже важно, кстати).

def popleft(self):
    if self.first is None:  # если список пустой, возвращаем None
        return None
    elif self.first == self.last:  # если список содержит только один элемент
        node = self.first  # сохраняем его
        self.__init__()  # очищаем
        return node  # и возвращаем сохраненный элемент
    else:
        node = self.first  # сохраняем первый элемент
        self.first = self.first.next  # меняем указатель на первый элемент
        return node  # возвращаем сохраненный
И немного более сложная процедура удаления последнего элемента:

def popright(self): 
    if self.first is None:  # если список пустой, возвращаем None
        return None
    elif self.first == self.last: #  если список содержит только один элемент
        node = self.first  # сохраняем его
        self.__init__()  # очищаем
        return node #  и возвращаем сохраненный элемент
    else:
        node = self.last  # сохраняем последний
        pointer = self.first  # создаем указатель
        while pointer.next is not node:  # пока не найдем предпоследний
            pointer = pointer.next
        pointer.next = None  # обнуляем указатели, чтобы
        self.last = pointer  # предпоследний стал последним
        return node  # возвращаем сохраненный
Задание 4.6.3
1/1 point (graded)
Как будет выглядеть список после выполнения последовательности операций?

LL = LinkedList()

LL.pushright(1)
LL.pushleft(2)
LL.pushright(3)
LL.popright()
LL.pushleft(4)
LL.pushright(5)
LL.popleft()

print(LL)
2 1 5
  верно 
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.Верно (1/1 балл)Review
Теперь, наконец, напишем функционал этого класса, чтобы он стал полноценным итератором.

def __iter__(self):  # объявляем класс как итератор
    self.current = self.first  # в текущий элемент помещаем первый
    return self  # возвращаем итератор

def __next__(self):  # метод перехода
    if self.current is None:  # если текущий стал последним
        raise StopIteration  # вызываем исключение
    else:
        node = self.current  # сохраняем текущий элемент
        self.current = self.current.next  # совершаем переход
        return node  # и возвращаем сохраненный
И в заключение напишем «магический» метод, возвращающий размер структуры данных.

def __len__(self):
    count = 0
    pointer = self.first
    while pointer is not None:
        count += 1
        pointer = pointer.next
    return count
Задание 4.6.4
1/1 point (graded)
Найдите размер списка из предыдущего задания.
3
  верно 
 
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.Верно (1/1 балл)Review
Вопрос 1: верно
